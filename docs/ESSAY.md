# Abstract
This project presents the design and implementation of a lightweight student grading system that emphasizes abstraction at multiple levels of software architecture. Rather than focusing on grading computations themselves, the system demonstrates how a modular and extensible structure can be built to support safe and controlled third-party integration. The main focus is safe third-party entegration. Despite its intentional minimalism, the system provides a scalable base that can be extended into larger applications, such as database or service oriented system. 

### Introduction
As mentioned earlier, the project focuses on designing a scalable system. Since extending the scope of the project was not an objective, an API was not implemented, which receive student data and stores it on a server. However, the requirement of storing data did not changed so that a CSV-based structure was used to simulate a database. The project was organized into two main packeges; grading and progression respectively. The grading package represents the core idea intended to operate on a web server, while the progresion package functions as a third-party library that communicates with the server. The simulated database is divided into two sections: student data and client data. Each client is assigned to one api_key, which must be verified before the library can be used. The primary motivation behind this project was not devlop a fully functional production system, but to explore architectural design decisions in a controlled an minimal enviroment.

### System Overview
In this project, there is no real database such as SQL. However, the requirement of data storing has never changed. There are basically two main scenarios: accessing student data and client data for third-party developres. For both usage, these data should be stored. Despite flexibility of SQL, the objective of the project would be exceeded if SQL based batabase was applied. Since CSV can be converted into an excel file and its lightweight, I chose CSV based database representation. The relationship between the grading and progression packages is quit simple. The grading package consists of the core logic, namely the statistical computaitons. On the other hand, the progression package is a library, which uses the grading packge to visualize the results.

### Package Design

##### Grading Package
The grading package was designed to represent the web-api package. It consists of two databases: one for student information and one for clients. The reason this package holds the core logic is that the required information is stored and accessed using tihs pacakge. Moreover, mathematical computations are performed using these database. This package was designed with server-side considerations, my main focuas was to learn the communicaiton between the server-side and the third-party developer side. It could also be designed as a real database; however, nothing would change except the level of abstraction. At this stage, it is used as a database abstraction.

##### Progress Package
This package is distributed via pip, which enables communication between third-party software developers and the core logic. This package gives an opportunity to visualize the database quickly. For this, `matplotlib` was used. It alos has features, such as adding new students to the CSV-based database. In this package the `check.py` file verifies the access permission for third-party software developers, so that not everyone can use this library, even if they install it. This permission should be checked once becuase otherwise it would have verified on each run.

### Data Representation and Validation
CSV was choosen becase it is not only readable for human but also convertible into excel file. Moreover, it is lighter than a excel file. Since CSV alone cannot guarantee some features, such as concurrency, integrity, and ACID properties, It can only simulates a database by adding an abstract layer. Validation runs on shell level to verify the permission once. It runs the `check.py` file on shell level.

### Tooling and Workflow
First of all, the third-party software developers should communicate with the owner to access a api key. After the api key delivered, the library could be used. During the developmnent process, Docker was used becuase of its flexibility. Containerization was introduced to ensure envicoment consistency across different development setups. By intentionally limiting the scope, the project focusses on understanding system boundaries, abstraction layers, and interaction between internal logic and external consumers.

### Limitations and Future Work
Not having a real database limits the project. Therefore, the CSV-based database can be switched to an SQL-based database. With this improvement, more than one third-party software developer can use this library. Furthermore, this project can be operated on a server in the future. Since the project represents a web API at this stage, it can offer guidance for future work, which means it has potential for extensions. Future extensions may also include role-based across control and more advanced validation machanisms to replace the current key-based verification model.       